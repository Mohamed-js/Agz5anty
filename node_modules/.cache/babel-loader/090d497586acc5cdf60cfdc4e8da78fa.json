{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport var UserMedia = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(UserMedia, _ToneAudioNode);\n\n  var _super = _createSuper(UserMedia);\n\n  function UserMedia() {\n    var _this;\n\n    _classCallCheck(this, UserMedia);\n\n    _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n\n  _createClass(UserMedia, [{\n    key: \"open\",\n    value:\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    function open(labelOrId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var devices, constraints, stream, mediaStreamNode;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n                if (this.state === \"started\") {\n                  this.close();\n                }\n\n                _context.next = 4;\n                return UserMedia.enumerateDevices();\n\n              case 4:\n                devices = _context.sent;\n\n                if (isNumber(labelOrId)) {\n                  this._device = devices[labelOrId];\n                } else {\n                  this._device = devices.find(function (device) {\n                    return device.label === labelOrId || device.deviceId === labelOrId;\n                  }); // didn't find a matching device\n\n                  if (!this._device && devices.length > 0) {\n                    this._device = devices[0];\n                  }\n\n                  assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n                } // do getUserMedia\n\n\n                constraints = {\n                  audio: {\n                    echoCancellation: false,\n                    sampleRate: this.context.sampleRate,\n                    noiseSuppression: false,\n                    mozNoiseSuppression: false\n                  }\n                };\n\n                if (this._device) {\n                  // @ts-ignore\n                  constraints.audio.deviceId = this._device.deviceId;\n                }\n\n                _context.next = 10;\n                return navigator.mediaDevices.getUserMedia(constraints);\n\n              case 10:\n                stream = _context.sent;\n\n                // start a new source only if the previous one is closed\n                if (!this._stream) {\n                  this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n                  mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n                  connect(mediaStreamNode, this.output);\n                  this._mediaStream = mediaStreamNode;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Close the media stream\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._stream && this._mediaStream) {\n        this._stream.getAudioTracks().forEach(function (track) {\n          track.stop();\n        });\n\n        this._stream = undefined; // remove the old media stream\n\n        this._mediaStream.disconnect();\n\n        this._mediaStream = undefined;\n      }\n\n      this._device = undefined;\n      return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n\n  }, {\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    function get() {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n\n  }, {\n    key: \"deviceId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n\n  }, {\n    key: \"groupId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(UserMedia.prototype), \"dispose\", this).call(this);\n\n      this.close();\n\n      this._volume.dispose();\n\n      this.volume.dispose();\n      return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var allDevices;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return navigator.mediaDevices.enumerateDevices();\n\n              case 2:\n                allDevices = _context2.sent;\n                return _context2.abrupt(\"return\", allDevices.filter(function (device) {\n                  return device.kind === \"audioinput\";\n                }));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"supported\",\n    get: function get() {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    }\n  }]);\n\n  return UserMedia;\n}(ToneAudioNode);","map":null,"metadata":{},"sourceType":"module"}