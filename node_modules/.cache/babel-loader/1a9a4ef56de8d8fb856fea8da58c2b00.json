{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode as _createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nexport var Context = /*#__PURE__*/function (_BaseContext) {\n  _inherits(Context, _BaseContext);\n\n  var _super = _createSuper(Context);\n\n  function Context() {\n    var _this;\n\n    _classCallCheck(this, Context);\n\n    _this = _super.call(this);\n    _this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    _this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    _this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    _this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    _this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    _this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    _this._workletModules = new Map();\n    var options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      _this._context = options.context;\n    } else {\n      _this._context = createAudioContext({\n        latencyHint: options.latencyHint\n      });\n    }\n\n    _this._ticker = new Ticker(_this.emit.bind(_assertThisInitialized(_this), \"tick\"), options.clockSource, options.updateInterval);\n\n    _this.on(\"tick\", _this._timeoutLoop.bind(_assertThisInitialized(_this))); // fwd events from the context\n\n\n    _this._context.onstatechange = function () {\n      _this.emit(\"statechange\", _this.state);\n    };\n\n    _this._setLatencyHint(options.latencyHint);\n\n    _this.lookAhead = options.lookAhead;\n    return _this;\n  }\n\n  _createClass(Context, [{\n    key: \"initialize\",\n    value:\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    function initialize() {\n      if (!this._initialized) {\n        // add any additional modules\n        initializeContext(this);\n        this._initialized = true;\n      }\n\n      return this;\n    } //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n\n  }, {\n    key: \"createAnalyser\",\n    value: function createAnalyser() {\n      return this._context.createAnalyser();\n    }\n  }, {\n    key: \"createOscillator\",\n    value: function createOscillator() {\n      return this._context.createOscillator();\n    }\n  }, {\n    key: \"createBufferSource\",\n    value: function createBufferSource() {\n      return this._context.createBufferSource();\n    }\n  }, {\n    key: \"createBiquadFilter\",\n    value: function createBiquadFilter() {\n      return this._context.createBiquadFilter();\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(numberOfChannels, length, sampleRate) {\n      return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n  }, {\n    key: \"createChannelMerger\",\n    value: function createChannelMerger(numberOfInputs) {\n      return this._context.createChannelMerger(numberOfInputs);\n    }\n  }, {\n    key: \"createChannelSplitter\",\n    value: function createChannelSplitter(numberOfOutputs) {\n      return this._context.createChannelSplitter(numberOfOutputs);\n    }\n  }, {\n    key: \"createConstantSource\",\n    value: function createConstantSource() {\n      return this._context.createConstantSource();\n    }\n  }, {\n    key: \"createConvolver\",\n    value: function createConvolver() {\n      return this._context.createConvolver();\n    }\n  }, {\n    key: \"createDelay\",\n    value: function createDelay(maxDelayTime) {\n      return this._context.createDelay(maxDelayTime);\n    }\n  }, {\n    key: \"createDynamicsCompressor\",\n    value: function createDynamicsCompressor() {\n      return this._context.createDynamicsCompressor();\n    }\n  }, {\n    key: \"createGain\",\n    value: function createGain() {\n      return this._context.createGain();\n    }\n  }, {\n    key: \"createIIRFilter\",\n    value: function createIIRFilter(feedForward, feedback) {\n      // @ts-ignore\n      return this._context.createIIRFilter(feedForward, feedback);\n    }\n  }, {\n    key: \"createPanner\",\n    value: function createPanner() {\n      return this._context.createPanner();\n    }\n  }, {\n    key: \"createPeriodicWave\",\n    value: function createPeriodicWave(real, imag, constraints) {\n      return this._context.createPeriodicWave(real, imag, constraints);\n    }\n  }, {\n    key: \"createStereoPanner\",\n    value: function createStereoPanner() {\n      return this._context.createStereoPanner();\n    }\n  }, {\n    key: \"createWaveShaper\",\n    value: function createWaveShaper() {\n      return this._context.createWaveShaper();\n    }\n  }, {\n    key: \"createMediaStreamSource\",\n    value: function createMediaStreamSource(stream) {\n      assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n      var context = this._context;\n      return context.createMediaStreamSource(stream);\n    }\n  }, {\n    key: \"createMediaElementSource\",\n    value: function createMediaElementSource(element) {\n      assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n      var context = this._context;\n      return context.createMediaElementSource(element);\n    }\n  }, {\n    key: \"createMediaStreamDestination\",\n    value: function createMediaStreamDestination() {\n      assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n      var context = this._context;\n      return context.createMediaStreamDestination();\n    }\n  }, {\n    key: \"decodeAudioData\",\n    value: function decodeAudioData(audioData) {\n      return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"sampleRate\",\n    get: function get() {\n      return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n\n  }, {\n    key: \"listener\",\n    get: function get() {\n      this.initialize();\n      return this._listener;\n    },\n    set: function set(l) {\n      assert(!this._initialized, \"The listener cannot be set after initialization.\");\n      this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n\n  }, {\n    key: \"transport\",\n    get: function get() {\n      this.initialize();\n      return this._transport;\n    },\n    set: function set(t) {\n      assert(!this._initialized, \"The transport cannot be set after initialization.\");\n      this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n\n  }, {\n    key: \"draw\",\n    get: function get() {\n      this.initialize();\n      return this._draw;\n    },\n    set: function set(d) {\n      assert(!this._initialized, \"Draw cannot be set after initialization.\");\n      this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n\n  }, {\n    key: \"destination\",\n    get: function get() {\n      this.initialize();\n      return this._destination;\n    },\n    set: function set(d) {\n      assert(!this._initialized, \"The destination cannot be set after initialization.\");\n      this._destination = d;\n    }\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n\n  }, {\n    key: \"createAudioWorkletNode\",\n    value: function createAudioWorkletNode(name, options) {\n      return _createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n\n  }, {\n    key: \"addAudioWorkletModule\",\n    value: function addAudioWorkletModule(url, name) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n                if (!this._workletModules.has(name)) {\n                  this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n                }\n\n                _context.next = 4;\n                return this._workletModules.get(name);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n\n  }, {\n    key: \"workletsAreReady\",\n    value: function workletsAreReady() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var promises;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                promises = [];\n\n                this._workletModules.forEach(function (promise) {\n                  return promises.push(promise);\n                });\n\n                _context2.next = 4;\n                return Promise.all(promises);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    } //---------------------------\n    // TICKER\n    //---------------------------\n\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n\n  }, {\n    key: \"updateInterval\",\n    get: function get() {\n      return this._ticker.updateInterval;\n    },\n    set: function set(interval) {\n      this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n\n  }, {\n    key: \"clockSource\",\n    get: function get() {\n      return this._ticker.type;\n    },\n    set: function set(type) {\n      this._ticker.type = type;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     * // the global context is gettable with Tone.getContext()\n     * console.log(Tone.getContext().latencyHint);\n     */\n\n  }, {\n    key: \"latencyHint\",\n    get: function get() {\n      return this._latencyHint;\n    }\n    /**\n     * Update the lookAhead and updateInterval based on the latencyHint\n     */\n\n  }, {\n    key: \"_setLatencyHint\",\n    value: function _setLatencyHint(hint) {\n      var lookAheadValue = 0;\n      this._latencyHint = hint;\n\n      if (isString(hint)) {\n        switch (hint) {\n          case \"interactive\":\n            lookAheadValue = 0.1;\n            break;\n\n          case \"playback\":\n            lookAheadValue = 0.5;\n            break;\n\n          case \"balanced\":\n            lookAheadValue = 0.25;\n            break;\n        }\n      }\n\n      this.lookAhead = lookAheadValue;\n      this.updateInterval = lookAheadValue / 2;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n\n  }, {\n    key: \"rawContext\",\n    get: function get() {\n      return this._context;\n    }\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n\n  }, {\n    key: \"now\",\n    value: function now() {\n      return this._context.currentTime + this.lookAhead;\n    }\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n\n  }, {\n    key: \"immediate\",\n    value: function immediate() {\n      return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext. See [[Tone.start]]\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (isAudioContext(this._context)) {\n        return this._context.resume();\n      } else {\n        return Promise.resolve();\n      }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!isAudioContext(this._context)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this._context.close();\n\n              case 3:\n                if (this._initialized) {\n                  closeContext(this);\n                }\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n\n  }, {\n    key: \"getConstant\",\n    value: function getConstant(val) {\n      if (this._constants.has(val)) {\n        return this._constants.get(val);\n      } else {\n        var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n        var arr = buffer.getChannelData(0);\n\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = val;\n        }\n\n        var constant = this._context.createBufferSource();\n\n        constant.channelCount = 1;\n        constant.channelCountMode = \"explicit\";\n        constant.buffer = buffer;\n        constant.loop = true;\n        constant.start(0);\n\n        this._constants.set(val, constant);\n\n        return constant;\n      }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Context.prototype), \"dispose\", this).call(this);\n\n      this._ticker.dispose();\n\n      this._timeouts.dispose();\n\n      Object.keys(this._constants).map(function (val) {\n        return _this2._constants[val].disconnect();\n      });\n      return this;\n    } //---------------------------\n    // TIMEOUTS\n    //---------------------------\n\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n\n  }, {\n    key: \"_timeoutLoop\",\n    value: function _timeoutLoop() {\n      var now = this.now();\n\n      var firstEvent = this._timeouts.peek();\n\n      while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n        // invoke the callback\n        firstEvent.callback(); // shift the first event off\n\n        this._timeouts.shift(); // get the next one\n\n\n        firstEvent = this._timeouts.peek();\n      }\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(fn, timeout) {\n      this._timeoutIds++;\n      var now = this.now();\n\n      this._timeouts.add({\n        callback: fn,\n        id: this._timeoutIds,\n        time: now + timeout\n      });\n\n      return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n\n  }, {\n    key: \"clearTimeout\",\n    value: function clearTimeout(id) {\n      var _this3 = this;\n\n      this._timeouts.forEach(function (event) {\n        if (event.id === id) {\n          _this3._timeouts.remove(event);\n        }\n      });\n\n      return this;\n    }\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n\n  }, {\n    key: \"clearInterval\",\n    value: function clearInterval(id) {\n      return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n\n  }, {\n    key: \"setInterval\",\n    value: function setInterval(fn, interval) {\n      var _this4 = this;\n\n      var id = ++this._timeoutIds;\n\n      var intervalFn = function intervalFn() {\n        var now = _this4.now();\n\n        _this4._timeouts.add({\n          callback: function callback() {\n            // invoke the callback\n            fn(); // invoke the event to repeat it\n\n            intervalFn();\n          },\n          id: id,\n          time: now + interval\n        });\n      }; // kick it off\n\n\n      intervalFn();\n      return id;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        clockSource: \"worker\",\n        latencyHint: \"interactive\",\n        lookAhead: 0.1,\n        updateInterval: 0.05\n      };\n    }\n  }]);\n\n  return Context;\n}(BaseContext);","map":null,"metadata":{},"sourceType":"module"}