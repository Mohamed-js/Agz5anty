{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nvar addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {\n  var _getAudioParamConnect = getAudioParamConnections(destination),\n      activeInputs = _getAudioParamConnect.activeInputs,\n      passiveInputs = _getAudioParamConnect.passiveInputs;\n\n  var _getAudioNodeConnecti = getAudioNodeConnections(source),\n      outputs = _getAudioNodeConnecti.outputs;\n\n  var eventListeners = getEventListenersOfAudioNode(source);\n\n  var eventListener = function eventListener(isActive) {\n    var nativeAudioNode = getNativeAudioNode(source);\n    var nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      var _partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n      addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], function (outputConnection) {\n    return outputConnection[0] === destination && outputConnection[1] === output;\n  }, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nvar deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {\n  var _getAudioNodeConnecti2 = getAudioNodeConnections(destination),\n      activeInputs = _getAudioNodeConnecti2.activeInputs,\n      passiveInputs = _getAudioNodeConnecti2.passiveInputs;\n\n  var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nvar deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {\n  var _getAudioParamConnect2 = getAudioParamConnections(destination),\n      activeInputs = _getAudioParamConnect2.activeInputs,\n      passiveInputs = _getAudioParamConnect2.passiveInputs;\n\n  var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nvar deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {\n  var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),\n      _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),\n      listener = _deleteInputConnectio2[0],\n      isActive = _deleteInputConnectio2[1];\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    var _getAudioNodeConnecti3 = getAudioNodeConnections(destination),\n        activeInputs = _getAudioNodeConnecti3.activeInputs;\n\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nvar deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {\n  var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),\n      _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),\n      listener = _deleteInputConnectio4[0],\n      isActive = _deleteInputConnectio4[1];\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nvar deleteAnyConnection = function deleteAnyConnection(source, isOffline) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n\n  var _iterator = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var outputConnection = _step.value;\n\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      } else {\n        deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      }\n\n      destinations.push(outputConnection[0]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nvar deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n\n  var _iterator2 = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var outputConnection = _step2.value;\n\n      if (outputConnection[1] === output) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n          deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        } else {\n          deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        }\n\n        destinations.push(outputConnection[0]);\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return destinations;\n};\n\nvar deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {\n    return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);\n  }).map(function (outputConnection) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    } else {\n      deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) {\n  return /*#__PURE__*/function (_eventTargetConstruct) {\n    _inherits(AudioNode, _eventTargetConstruct);\n\n    var _super = _createSuper(AudioNode);\n\n    function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      var _this;\n\n      _classCallCheck(this, AudioNode);\n\n      _this = _super.call(this, nativeAudioNode);\n      _this._context = context;\n      _this._nativeAudioNode = nativeAudioNode;\n      var nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {\n        return testAudioNodeDisconnectMethodSupport(nativeContext);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(_assertThisInitialized(_this), nativeAudioNode);\n      EVENT_LISTENERS.set(_assertThisInitialized(_this), new Set());\n\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(_assertThisInitialized(_this));\n      }\n\n      addAudioNodeConnections(_assertThisInitialized(_this), audioNodeRenderer, nativeAudioNode);\n      return _this;\n    }\n\n    _createClass(AudioNode, [{\n      key: \"channelCount\",\n      get: function get() {\n        return this._nativeAudioNode.channelCount;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCount = value;\n      }\n    }, {\n      key: \"channelCountMode\",\n      get: function get() {\n        return this._nativeAudioNode.channelCountMode;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCountMode = value;\n      }\n    }, {\n      key: \"channelInterpretation\",\n      get: function get() {\n        return this._nativeAudioNode.channelInterpretation;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelInterpretation = value;\n      }\n    }, {\n      key: \"context\",\n      get: function get() {\n        return this._context;\n      }\n    }, {\n      key: \"numberOfInputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfInputs;\n      }\n    }, {\n      key: \"numberOfOutputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfOutputs;\n      } // tslint:disable-next-line:invalid-void\n\n    }, {\n      key: \"connect\",\n      value: function connect(destination) {\n        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n        if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n          throw createInvalidAccessError();\n        }\n\n        if (isAudioNode(destination)) {\n          var nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n          try {\n            var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n            var isPassive = isPassiveAudioNode(this);\n\n            if (isOffline || isPassive) {\n              var _this$_nativeAudioNod;\n\n              (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));\n            }\n\n            if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n              setInternalStateToActive(destination);\n            }\n          } catch (err) {\n            // Bug #41: Safari does not throw the correct exception so far.\n            if (err.code === 12) {\n              throw createInvalidAccessError();\n            }\n\n            throw err;\n          }\n\n          var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n          if (isNewConnectionToAudioNode) {\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n          }\n\n          return destination;\n        }\n\n        var nativeAudioParam = getNativeAudioParam(destination);\n        /*\n         * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n         * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n         * Safari.\n         */\n\n        if (nativeAudioParam.name === 'playbackRate') {\n          throw createNotSupportedError();\n        }\n\n        try {\n          this._nativeAudioNode.connect(nativeAudioParam, output);\n\n          if (isOffline || isPassiveAudioNode(this)) {\n            this._nativeAudioNode.disconnect(nativeAudioParam, output);\n          }\n        } catch (err) {\n          // Bug #58: Only Firefox does throw an InvalidStateError yet.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioParam) {\n          var _cycles = detectCycles([this], destination);\n\n          visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));\n        }\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect(destinationOrOutput, output, input) {\n        var destinations;\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (destinationOrOutput === undefined) {\n          destinations = deleteAnyConnection(this, isOffline);\n        } else if (typeof destinationOrOutput === 'number') {\n          if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n            throw createIndexSizeError();\n          }\n\n          destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n        } else {\n          if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n            throw createIndexSizeError();\n          }\n\n          if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n            throw createIndexSizeError();\n          }\n\n          destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n          if (destinations.length === 0) {\n            throw createInvalidAccessError();\n          }\n        } // Bug #164: Only Firefox detects cycles so far.\n\n\n        var _iterator3 = _createForOfIteratorHelper(destinations),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var destination = _step3.value;\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }]);\n\n    return AudioNode;\n  }(eventTargetConstructor);\n};","map":null,"metadata":{},"sourceType":"module"}