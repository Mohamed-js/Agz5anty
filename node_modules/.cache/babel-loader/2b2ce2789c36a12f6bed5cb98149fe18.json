{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport var Source = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Source, _ToneAudioNode);\n\n  var _super = _createSuper(Source);\n\n  function Source(options) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _super.call(this, options);\n    /**\n     * Sources have no inputs\n     */\n\n    _this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    _this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    _this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    _this._syncedStart = noOp;\n    _this._syncedStop = noOp;\n    _this._state.memory = 100;\n    _this._state.increasing = true;\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.onstop = options.onstop;\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    function get() {\n      if (this._synced) {\n        if (this.context.transport.state === \"started\") {\n          return this._state.getValueAtTime(this.context.transport.seconds);\n        } else {\n          return \"stopped\";\n        }\n      } else {\n        return this._state.getValueAtTime(this.now());\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n\n  }, {\n    key: \"_clampToCurrentTime\",\n    value: function _clampToCurrentTime(time) {\n      if (this._synced) {\n        return time;\n      } else {\n        return Math.max(time, this.context.currentTime);\n      }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset, duration) {\n      var _this2 = this;\n\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n      if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n        // time should be strictly greater than the previous start time\n        assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        this.log(\"restart\", computedTime);\n        this.restart(computedTime, offset, duration);\n      } else {\n        this.log(\"start\", computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (this._synced) {\n          // add the offset time to the event\n          var event = this._state.get(computedTime);\n\n          if (event) {\n            event.offset = this.toSeconds(defaultArg(offset, 0));\n            event.duration = duration ? this.toSeconds(duration) : undefined;\n          }\n\n          var sched = this.context.transport.schedule(function (t) {\n            _this2._start(t, offset, duration);\n          }, computedTime);\n\n          this._scheduled.push(sched); // if the transport is already started\n          // and the time is greater than where the transport is\n\n\n          if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n            this._syncedStart(this.now(), this.context.transport.seconds);\n          }\n        } else {\n          assertContextRunning(this.context);\n\n          this._start(computedTime, offset, duration);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n        this.log(\"stop\", computedTime);\n\n        if (!this._synced) {\n          this._stop(computedTime);\n        } else {\n          var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n          this._scheduled.push(sched);\n        }\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"stopped\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Restart the source.\n     */\n\n  }, {\n    key: \"restart\",\n    value: function restart(time, offset, duration) {\n      time = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(time) === \"started\") {\n        this._state.cancel(time);\n\n        this._restart(time, offset, duration);\n      }\n\n      return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var _this3 = this;\n\n      if (!this._synced) {\n        this._synced = true;\n\n        this._syncedStart = function (time, offset) {\n          if (offset > 0) {\n            // get the playback state at that time\n            var stateEvent = _this3._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n            if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n              // get the offset\n              var startOffset = offset - _this3.toSeconds(stateEvent.time);\n\n              var duration;\n\n              if (stateEvent.duration) {\n                duration = _this3.toSeconds(stateEvent.duration) - startOffset;\n              }\n\n              _this3._start(time, _this3.toSeconds(stateEvent.offset) + startOffset, duration);\n            }\n          }\n        };\n\n        this._syncedStop = function (time) {\n          var seconds = _this3.context.transport.getSecondsAtTime(Math.max(time - _this3.sampleTime, 0));\n\n          if (_this3._state.getValueAtTime(seconds) === \"started\") {\n            _this3._stop(time);\n          }\n        };\n\n        this.context.transport.on(\"start\", this._syncedStart);\n        this.context.transport.on(\"loopStart\", this._syncedStart);\n        this.context.transport.on(\"stop\", this._syncedStop);\n        this.context.transport.on(\"pause\", this._syncedStop);\n        this.context.transport.on(\"loopEnd\", this._syncedStop);\n      }\n\n      return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      var _this4 = this;\n\n      if (this._synced) {\n        this.context.transport.off(\"stop\", this._syncedStop);\n        this.context.transport.off(\"pause\", this._syncedStop);\n        this.context.transport.off(\"loopEnd\", this._syncedStop);\n        this.context.transport.off(\"start\", this._syncedStart);\n        this.context.transport.off(\"loopStart\", this._syncedStart);\n      }\n\n      this._synced = false; // clear all of the scheduled ids\n\n      this._scheduled.forEach(function (id) {\n        return _this4.context.transport.clear(id);\n      });\n\n      this._scheduled = [];\n\n      this._state.cancel(0); // stop it also\n\n\n      this._stop(0);\n\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Source.prototype), \"dispose\", this).call(this);\n\n      this.onstop = noOp;\n      this.unsync();\n\n      this._volume.dispose();\n\n      this._state.dispose();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        onstop: noOp,\n        volume: 0\n      });\n    }\n  }]);\n\n  return Source;\n}(ToneAudioNode);","map":null,"metadata":{},"sourceType":"module"}