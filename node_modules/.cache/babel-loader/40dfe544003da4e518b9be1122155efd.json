{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport var Noise = /*#__PURE__*/function (_Source) {\n  _inherits(Noise, _Source);\n\n  var _super = _createSuper(Noise);\n\n  function Noise() {\n    var _this;\n\n    _classCallCheck(this, Noise);\n\n    _this = _super.call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    _this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    _this._source = null;\n    var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    _this._playbackRate = options.playbackRate;\n    _this.type = options.type;\n    _this._fadeIn = options.fadeIn;\n    _this._fadeOut = options.fadeOut;\n    return _this;\n  }\n\n  _createClass(Noise, [{\n    key: \"type\",\n    get:\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n      if (this._type !== type) {\n        this._type = type; // if it's playing, stop and restart it\n\n        if (this.state === \"started\") {\n          var now = this.now();\n\n          this._stop(now);\n\n          this._start(now);\n        }\n      }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n\n      if (this._source) {\n        this._source.playbackRate.value = rate;\n      }\n    }\n    /**\n     * internal start method\n     */\n\n  }, {\n    key: \"_start\",\n    value: function _start(time) {\n      var _this2 = this;\n\n      var buffer = _noiseBuffers[this._type];\n      this._source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        fadeIn: this._fadeIn,\n        fadeOut: this._fadeOut,\n        loop: true,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        },\n        playbackRate: this._playbackRate\n      }).connect(this.output);\n\n      this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      if (this._source) {\n        this._source.stop(this.toSeconds(time));\n\n        this._source = null;\n      }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"fadeIn\",\n    get: function get() {\n      return this._fadeIn;\n    },\n    set: function set(time) {\n      this._fadeIn = time;\n\n      if (this._source) {\n        this._source.fadeIn = this._fadeIn;\n      }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"fadeOut\",\n    get: function get() {\n      return this._fadeOut;\n    },\n    set: function set(time) {\n      this._fadeOut = time;\n\n      if (this._source) {\n        this._source.fadeOut = this._fadeOut;\n      }\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      // TODO could be optimized by cancelling the buffer source 'stop'\n      this._stop(time);\n\n      this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Noise.prototype), \"dispose\", this).call(this);\n\n      if (this._source) {\n        this._source.disconnect();\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        fadeIn: 0,\n        fadeOut: 0,\n        playbackRate: 1,\n        type: \"white\"\n      });\n    }\n  }]);\n\n  return Noise;\n}(Source); //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nvar _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nvar _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var lastOut = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var b0 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            b3 = void 0,\n            b4 = void 0,\n            b5 = void 0,\n            b6 = void 0;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}