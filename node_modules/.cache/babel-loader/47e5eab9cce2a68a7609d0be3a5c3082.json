{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport var createNativeAudioWorkletNodeFakerFactory = function createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) {\n  return function (nativeContext, baseLatency, processorConstructor, options) {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    var outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n\n    if (outputChannelCount.some(function (channelCount) {\n      return channelCount < 1;\n    })) {\n      throw createNotSupportedError();\n    }\n\n    if (outputChannelCount.length !== options.numberOfOutputs) {\n      throw createIndexSizeError();\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    var numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    var numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n      return sum + value;\n    }, 0);\n    var numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    var messageChannel = new MessageChannel();\n    var gainNodes = [];\n    var inputChannelSplitterNodes = [];\n\n    for (var i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    var constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      var _iterator = _createForOfIteratorHelper(processorConstructor.parameterDescriptors),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var _ref = _step.value;\n          var defaultValue = _ref.defaultValue;\n          var maxValue = _ref.maxValue;\n          var minValue = _ref.minValue;\n          var name = _ref.name;\n          var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n          });\n          Object.defineProperties(constantSourceNode.offset, {\n            defaultValue: {\n              get: function get() {\n                return defaultValue === undefined ? 0 : defaultValue;\n              }\n            },\n            maxValue: {\n              get: function get() {\n                return maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue;\n              }\n            },\n            minValue: {\n              get: function get() {\n                return minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue;\n              }\n            }\n          });\n          constantSourceNodes.push(constantSourceNode);\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    var inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    var outputChannelMergerNodes = [];\n\n    for (var _i = 0; _i < options.numberOfOutputs; _i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: outputChannelCount[_i]\n      }));\n    }\n\n    for (var _i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n      gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n      for (var j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n      }\n    }\n\n    var parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(function (_ref2, index) {\n      var name = _ref2.name;\n      var constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    var channelInterpretation = options.channelInterpretation;\n    var onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    var outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    var nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        var _iterator2 = _createForOfIteratorHelper(gainNodes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var gainNode = _step2.value;\n            gainNode.channelInterpretation = value;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener: function addEventListener() {\n        return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n      dispatchEvent: function dispatchEvent() {\n        return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    var patchedEventListeners = new Map();\n\n    messageChannel.port1.addEventListener = function (addEventListener) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (args[0] === 'message') {\n          var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            var patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = function (event) {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n                  return unpatchedEventListener(event);\n                });\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = function (removeEventListener) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (args[0] === 'message') {\n          var patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.removeEventListener);\n\n    var onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: function get() {\n        return onmessage;\n      },\n      set: function set(value) {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    var audioWorkletProcessor = null;\n    var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(function (dWrkltPrcssr) {\n      return audioWorkletProcessor = dWrkltPrcssr;\n    });\n    var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    var outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    var parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce(function (prmtrs, _ref3) {\n      var name = _ref3.name;\n      return _objectSpread(_objectSpread({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n    }, {});\n    var isActive = true;\n\n    var disconnectOutputsGraph = function disconnectOutputsGraph() {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (var _i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < options.numberOfOutputs; _i3 += 1) {\n        var outputChannelMergerNode = outputChannelMergerNodes[_i3];\n\n        for (var _j = 0; _j < outputChannelCount[_i3]; _j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j, _j);\n        }\n\n        outputChannelSplitterNodeOutput += outputChannelCount[_i3];\n      }\n    };\n\n    var activeInputIndexes = new Map(); // tslint:disable-next-line:deprecation\n\n    scriptProcessorNode.onaudioprocess = function (_ref4) {\n      var inputBuffer = _ref4.inputBuffer,\n          outputBuffer = _ref4.outputBuffer;\n\n      if (audioWorkletProcessor !== null) {\n        (function () {\n          var activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n          var _loop2 = function _loop2(_i4) {\n            for (var _j2 = 0; _j2 < options.numberOfInputs; _j2 += 1) {\n              for (var k = 0; k < options.channelCount; k += 1) {\n                copyFromChannel(inputBuffer, inputs[_j2], k, k, _i4);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              processorConstructor.parameterDescriptors.forEach(function (_ref5, index) {\n                var name = _ref5.name;\n                copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, _i4);\n              });\n            }\n\n            for (var _j3 = 0; _j3 < options.numberOfInputs; _j3 += 1) {\n              for (var _k = 0; _k < outputChannelCount[_j3]; _k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[_j3][_k].byteLength === 0) {\n                  outputs[_j3][_k] = new Float32Array(128);\n                }\n              }\n            }\n\n            try {\n              var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                var activeInput = activeInputs[index];\n\n                if (activeInput.size > 0) {\n                  activeInputIndexes.set(index, bufferSize / 128);\n                  return input;\n                }\n\n                var count = activeInputIndexes.get(index);\n\n                if (count === undefined) {\n                  return [];\n                }\n\n                if (input.every(function (channelData) {\n                  return channelData.every(function (sample) {\n                    return sample === 0;\n                  });\n                })) {\n                  if (count === 1) {\n                    activeInputIndexes.delete(index);\n                  } else {\n                    activeInputIndexes.set(index, count - 1);\n                  }\n                }\n\n                return input;\n              });\n              var activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + _i4 / nativeContext.sampleRate, nativeContext.sampleRate, function () {\n                return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n              });\n              isActive = activeSourceFlag;\n\n              for (var _j4 = 0, outputChannelSplitterNodeOutput = 0; _j4 < options.numberOfOutputs; _j4 += 1) {\n                for (var _k2 = 0; _k2 < outputChannelCount[_j4]; _k2 += 1) {\n                  copyToChannel(outputBuffer, outputs[_j4], _k2, outputChannelSplitterNodeOutput + _k2, _i4);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[_j4];\n              }\n            } catch (error) {\n              isActive = false;\n              nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n              }));\n            }\n\n            if (!isActive) {\n              for (var _j5 = 0; _j5 < options.numberOfInputs; _j5 += 1) {\n                gainNodes[_j5].disconnect(inputChannelSplitterNodes[_j5]);\n\n                for (var _k3 = 0; _k3 < options.channelCount; _k3 += 1) {\n                  inputChannelSplitterNodes[_i4].disconnect(inputChannelMergerNode, _k3, _j5 * options.channelCount + _k3);\n                }\n              }\n\n              if (processorConstructor.parameterDescriptors !== undefined) {\n                var length = processorConstructor.parameterDescriptors.length;\n\n                for (var _j6 = 0; _j6 < length; _j6 += 1) {\n                  var constantSourceNode = constantSourceNodes[_j6];\n                  constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + _j6);\n                  constantSourceNode.stop();\n                }\n              }\n\n              inputChannelMergerNode.disconnect(scriptProcessorNode);\n              scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n              if (isConnected) {\n                disconnectOutputsGraph();\n              } else {\n                disconnectFakeGraph();\n              }\n\n              return \"break\";\n            }\n          };\n\n          for (var _i4 = 0; _i4 < bufferSize; _i4 += 128) {\n            var _ret = _loop2(_i4);\n\n            if (_ret === \"break\") break;\n          }\n        })();\n      }\n    };\n\n    var isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    var nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    var connectFakeGraph = function connectFakeGraph() {\n      return scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n    };\n\n    var disconnectFakeGraph = function disconnectFakeGraph() {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    var whenConnected = function whenConnected() {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (var _i5 = 0, outputChannelSplitterNodeOutput = 0; _i5 < options.numberOfOutputs; _i5 += 1) {\n          var outputChannelMergerNode = outputChannelMergerNodes[_i5];\n\n          for (var _j7 = 0; _j7 < outputChannelCount[_i5]; _j7 += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j7, _j7);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[_i5];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":null,"metadata":{},"sourceType":"module"}