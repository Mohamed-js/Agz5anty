{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport var TickSource = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(TickSource, _ToneWithContext);\n\n  var _super = _createSuper(TickSource);\n\n  function TickSource() {\n    var _this;\n\n    _classCallCheck(this, TickSource);\n\n    _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\"); // set the initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    _this.setTicksAtTime(0, 0);\n\n    return _this;\n  }\n\n  _createClass(TickSource, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (isDefined(offset)) {\n          this.setTicksAtTime(offset, computedTime);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time); // cancel the previous stop\n\n      if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n        var event = this._state.get(computedTime);\n\n        if (event && event.time > 0) {\n          this._tickOffset.cancel(event.time);\n\n          this._state.cancel(event.time);\n        }\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n\n      this.setTicksAtTime(0, computedTime);\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      time = this.toSeconds(time);\n\n      this._state.cancel(time);\n\n      this._tickOffset.cancel(time);\n\n      return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var _this2 = this;\n\n      var computedTime = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: computedTime\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedTicks = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this2._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedTicks = offsetEvent.ticks;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedTicks += _this2.frequency.getTicksAtTime(e.time) - _this2.frequency.getTicksAtTime(periodStartTime);\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function set(t) {\n      this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      var _this3 = this;\n\n      time = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: time\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedSeconds = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this3._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedSeconds = offsetEvent.seconds;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedSeconds += e.time - periodStartTime;\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      time = this.toSeconds(time);\n\n      this._tickOffset.cancel(time);\n\n      this._tickOffset.add({\n        seconds: this.frequency.getDurationOfTicks(ticks, time),\n        ticks: ticks,\n        time: time\n      });\n\n      return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      time = this.toSeconds(time);\n      return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n\n      var offset = this._tickOffset.get(before);\n\n      var event = this._state.get(before);\n\n      var startTime = Math.max(offset.time, event.time);\n      var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n      return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n\n  }, {\n    key: \"forEachTickBetween\",\n    value: function forEachTickBetween(startTime, endTime, callback) {\n      var _this4 = this;\n\n      // only iterate through the sections where it is \"started\"\n      var lastStateEvent = this._state.get(startTime);\n\n      this._state.forEachBetween(startTime, endTime, function (event) {\n        if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n          _this4.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this4.sampleTime, callback);\n        }\n\n        lastStateEvent = event;\n      });\n\n      var error = null;\n\n      if (lastStateEvent && lastStateEvent.state === \"started\") {\n        var maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n        var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n        var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n        var diff = startTicks - ticksAtStart;\n        var offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n        offset = EQ(offset, 1) ? 0 : offset;\n        var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n        while (nextTickTime < endTime) {\n          try {\n            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n          } catch (e) {\n            error = e;\n            break;\n          }\n\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    }\n    /**\n     * Clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSource.prototype), \"dispose\", this).call(this);\n\n      this._state.dispose();\n\n      this._tickOffset.dispose();\n\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign({\n        frequency: 1,\n        units: \"hertz\"\n      }, ToneWithContext.getDefaults());\n    }\n  }]);\n\n  return TickSource;\n}(ToneWithContext);","map":null,"metadata":{},"sourceType":"module"}