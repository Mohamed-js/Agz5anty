{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\n\nexport var TimeClass = /*#__PURE__*/function (_TimeBaseClass) {\n  _inherits(TimeClass, _TimeBaseClass);\n\n  var _super = _createSuper(TimeClass);\n\n  function TimeClass() {\n    var _this;\n\n    _classCallCheck(this, TimeClass);\n\n    _this = _super.apply(this, arguments);\n    _this.name = \"TimeClass\";\n    return _this;\n  }\n\n  _createClass(TimeClass, [{\n    key: \"_getExpressions\",\n    value: function _getExpressions() {\n      var _this2 = this;\n\n      return Object.assign(_get(_getPrototypeOf(TimeClass.prototype), \"_getExpressions\", this).call(this), {\n        now: {\n          method: function method(capture) {\n            return _this2._now() + new _this2.constructor(_this2.context, capture).valueOf();\n          },\n          regexp: /^\\+(.+)/\n        },\n        quantize: {\n          method: function method(capture) {\n            var quantTo = new TimeClass(_this2.context, capture).valueOf();\n            return _this2._secondsToUnits(_this2.context.transport.nextSubdivision(quantTo));\n          },\n          regexp: /^@(.+)/\n        }\n      });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n\n  }, {\n    key: \"quantize\",\n    value: function quantize(subdiv) {\n      var percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var subdivision = new this.constructor(this.context, subdiv).valueOf();\n      var value = this.valueOf();\n      var multiple = Math.round(value / subdivision);\n      var ideal = multiple * subdivision;\n      var diff = ideal - value;\n      return value + diff * percent;\n    } //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n\n  }, {\n    key: \"toNotation\",\n    value: function toNotation() {\n      var _this3 = this;\n\n      var time = this.toSeconds();\n      var testNotations = [\"1m\"];\n\n      for (var power = 1; power < 9; power++) {\n        var subdiv = Math.pow(2, power);\n        testNotations.push(subdiv + \"n.\");\n        testNotations.push(subdiv + \"n\");\n        testNotations.push(subdiv + \"t\");\n      }\n\n      testNotations.push(\"0\"); // find the closets notation representation\n\n      var closest = testNotations[0];\n      var closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n      testNotations.forEach(function (notation) {\n        var notationSeconds = new TimeClass(_this3.context, notation).toSeconds();\n\n        if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n          closest = notation;\n          closestSeconds = notationSeconds;\n        }\n      });\n      return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n\n  }, {\n    key: \"toBarsBeatsSixteenths\",\n    value: function toBarsBeatsSixteenths() {\n      var quarterTime = this._beatsToUnits(1);\n\n      var quarters = this.valueOf() / quarterTime;\n      quarters = parseFloat(quarters.toFixed(4));\n      var measures = Math.floor(quarters / this._getTimeSignature());\n      var sixteenths = quarters % 1 * 4;\n      quarters = Math.floor(quarters) % this._getTimeSignature();\n      var sixteenthString = sixteenths.toString();\n\n      if (sixteenthString.length > 3) {\n        // the additional parseFloat removes insignificant trailing zeroes\n        sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n      }\n\n      var progress = [measures, quarters, sixteenths];\n      return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n\n  }, {\n    key: \"toTicks\",\n    value: function toTicks() {\n      var quarterTime = this._beatsToUnits(1);\n\n      var quarters = this.valueOf() / quarterTime;\n      return quarters * this._getPPQ();\n    }\n    /**\n     * Return the time in seconds.\n     */\n\n  }, {\n    key: \"toSeconds\",\n    value: function toSeconds() {\n      return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n\n  }, {\n    key: \"toMidi\",\n    value: function toMidi() {\n      return ftom(this.toFrequency());\n    }\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return this.context.now();\n    }\n  }]);\n\n  return TimeClass;\n}(TimeBaseClass);\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\n\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","map":null,"metadata":{},"sourceType":"module"}