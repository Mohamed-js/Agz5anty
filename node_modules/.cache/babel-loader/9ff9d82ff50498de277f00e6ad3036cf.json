{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport var Part = /*#__PURE__*/function (_ToneEvent) {\n  _inherits(Part, _ToneEvent);\n\n  var _super = _createSuper(Part);\n\n  function Part() {\n    var _this;\n\n    _classCallCheck(this, Part);\n\n    _this = _super.call(this, optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n    _this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n\n    _this._events = new Set();\n    var options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]); // make sure things are assigned in the right order\n\n    _this._state.increasing = true; // add the events\n\n    options.events.forEach(function (event) {\n      if (isArray(event)) {\n        _this.add(event[0], event[1]);\n      } else {\n        _this.add(event);\n      }\n    });\n    return _this;\n  }\n\n  _createClass(Part, [{\n    key: \"start\",\n    value:\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset from the start of the part to begin playing at.\n     */\n    function start(time, offset) {\n      var _this2 = this;\n\n      var ticks = this.toTicks(time);\n\n      if (this._state.getValueAtTime(ticks) !== \"started\") {\n        offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\n        if (this._loop) {\n          offset = defaultArg(offset, this._loopStart);\n        } else {\n          offset = defaultArg(offset, 0);\n        }\n\n        var computedOffset = this.toTicks(offset);\n\n        this._state.add({\n          id: -1,\n          offset: computedOffset,\n          state: \"started\",\n          time: ticks\n        });\n\n        this._forEach(function (event) {\n          _this2._startNote(event, ticks, computedOffset);\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Start the event in the given event at the correct time given\n     * the ticks and offset and looping.\n     * @param  event\n     * @param  ticks\n     * @param  offset\n     */\n\n  }, {\n    key: \"_startNote\",\n    value: function _startNote(event, ticks, offset) {\n      ticks -= offset;\n\n      if (this._loop) {\n        if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n          if (event.startOffset < offset) {\n            // start it on the next loop\n            ticks += this._getLoopDuration();\n          }\n\n          event.start(new TicksClass(this.context, ticks));\n        } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n          event.loop = false;\n          event.start(new TicksClass(this.context, ticks));\n        }\n      } else if (event.startOffset >= offset) {\n        event.start(new TicksClass(this.context, ticks));\n      }\n    }\n  }, {\n    key: \"startOffset\",\n    get: function get() {\n      return this._startOffset;\n    },\n    set: function set(offset) {\n      var _this3 = this;\n\n      this._startOffset = offset;\n\n      this._forEach(function (event) {\n        event.startOffset += _this3._startOffset;\n      });\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var ticks = this.toTicks(time);\n\n      this._state.cancel(ticks);\n\n      this._state.setStateAtTime(\"stopped\", ticks);\n\n      this._forEach(function (event) {\n        event.stop(time);\n      });\n\n      return this;\n    }\n    /**\n     * Get/Set an Event's value at the given time.\n     * If a value is passed in and no event exists at\n     * the given time, one will be created with that value.\n     * If two events are at the same time, the first one will\n     * be returned.\n     * @example\n     * const part = new Tone.Part();\n     * part.at(\"1m\"); // returns the part at the first measure\n     * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n     * // if an event didn't exist at that time, it will be created.\n     * @param time The time of the event to get or set.\n     * @param value If a value is passed in, the value of the event at the given time will be set to it.\n     */\n\n  }, {\n    key: \"at\",\n    value: function at(time, value) {\n      var timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n      var tickTime = new TicksClass(this.context, 1).toSeconds();\n\n      var iterator = this._events.values();\n\n      var result = iterator.next();\n\n      while (!result.done) {\n        var event = result.value;\n\n        if (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n          if (isDefined(value)) {\n            event.value = value;\n          }\n\n          return event;\n        }\n\n        result = iterator.next();\n      } // if there was no event at that time, create one\n\n\n      if (isDefined(value)) {\n        this.add(time, value); // return the new event\n\n        return this.at(time);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(time, value) {\n      // extract the parameters\n      if (time instanceof Object && Reflect.has(time, \"time\")) {\n        value = time;\n        time = value.time;\n      }\n\n      var ticks = this.toTicks(time);\n      var event;\n\n      if (value instanceof ToneEvent) {\n        event = value;\n        event.callback = this._tick.bind(this);\n      } else {\n        event = new ToneEvent({\n          callback: this._tick.bind(this),\n          context: this.context,\n          value: value\n        });\n      } // the start offset\n\n\n      event.startOffset = ticks; // initialize the values\n\n      event.set({\n        humanize: this.humanize,\n        loop: this.loop,\n        loopEnd: this.loopEnd,\n        loopStart: this.loopStart,\n        playbackRate: this.playbackRate,\n        probability: this.probability\n      });\n\n      this._events.add(event); // start the note if it should be played right now\n\n\n      this._restartEvent(event);\n\n      return this;\n    }\n    /**\n     * Restart the given event\n     */\n\n  }, {\n    key: \"_restartEvent\",\n    value: function _restartEvent(event) {\n      var _this4 = this;\n\n      this._state.forEach(function (stateEvent) {\n        if (stateEvent.state === \"started\") {\n          _this4._startNote(event, stateEvent.time, stateEvent.offset);\n        } else {\n          // stop the note\n          event.stop(new TicksClass(_this4.context, stateEvent.time));\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(time, value) {\n      var _this5 = this;\n\n      // extract the parameters\n      if (isObject(time) && time.hasOwnProperty(\"time\")) {\n        value = time;\n        time = value.time;\n      }\n\n      time = this.toTicks(time);\n\n      this._events.forEach(function (event) {\n        if (event.startOffset === time) {\n          if (isUndef(value) || isDefined(value) && event.value === value) {\n            _this5._events.delete(event);\n\n            event.dispose();\n          }\n        }\n      });\n\n      return this;\n    }\n    /**\n     * Remove all of the notes from the group.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._forEach(function (event) {\n        return event.dispose();\n      });\n\n      this._events.clear();\n\n      return this;\n    }\n    /**\n     * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n     * @param after The time after which to cancel the scheduled events.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      this._forEach(function (event) {\n        return event.cancel(after);\n      });\n\n      this._state.cancel(this.toTicks(after));\n\n      return this;\n    }\n    /**\n     * Iterate over all of the events\n     */\n\n  }, {\n    key: \"_forEach\",\n    value: function _forEach(callback) {\n      if (this._events) {\n        this._events.forEach(function (event) {\n          if (event instanceof Part) {\n            event._forEach(callback);\n          } else {\n            callback(event);\n          }\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Set the attribute of all of the events\n     * @param  attr  the attribute to set\n     * @param  value      The value to set it to\n     */\n\n  }, {\n    key: \"_setAll\",\n    value: function _setAll(attr, value) {\n      this._forEach(function (event) {\n        event[attr] = value;\n      });\n    }\n    /**\n     * Internal tick method\n     * @param  time  The time of the event in seconds\n     */\n\n  }, {\n    key: \"_tick\",\n    value: function _tick(time, value) {\n      if (!this.mute) {\n        this.callback(time, value);\n      }\n    }\n    /**\n     * Determine if the event should be currently looping\n     * given the loop boundries of this Part.\n     * @param  event  The event to test\n     */\n\n  }, {\n    key: \"_testLoopBoundries\",\n    value: function _testLoopBoundries(event) {\n      if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n        event.cancel(0);\n      } else if (event.state === \"stopped\") {\n        // reschedule it if it's stopped\n        this._restartEvent(event);\n      }\n    }\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._probability;\n    },\n    set: function set(prob) {\n      this._probability = prob;\n\n      this._setAll(\"probability\", prob);\n    }\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._humanize;\n    },\n    set: function set(variation) {\n      this._humanize = variation;\n\n      this._setAll(\"humanize\", variation);\n    }\n    /**\n     * If the part should loop or not\n     * between Part.loopStart and\n     * Part.loopEnd. If set to true,\n     * the part will loop indefinitely,\n     * if set to a number greater than 1\n     * it will play a specific number of\n     * times, if set to false, 0 or 1, the\n     * part will only play once.\n     * @example\n     * const part = new Tone.Part();\n     * // loop the part 8 times\n     * part.loop = 8;\n     */\n\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop;\n    },\n    set: function set(loop) {\n      var _this6 = this;\n\n      this._loop = loop;\n\n      this._forEach(function (event) {\n        event.loopStart = _this6.loopStart;\n        event.loopEnd = _this6.loopEnd;\n        event.loop = loop;\n\n        _this6._testLoopBoundries(event);\n      });\n    }\n    /**\n     * The loopEnd point determines when it will\n     * loop if Part.loop is true.\n     */\n\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return new TicksClass(this.context, this._loopEnd).toSeconds();\n    },\n    set: function set(loopEnd) {\n      var _this7 = this;\n\n      this._loopEnd = this.toTicks(loopEnd);\n\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopEnd = loopEnd;\n\n          _this7._testLoopBoundries(event);\n        });\n      }\n    }\n    /**\n     * The loopStart point determines when it will\n     * loop if Part.loop is true.\n     */\n\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return new TicksClass(this.context, this._loopStart).toSeconds();\n    },\n    set: function set(loopStart) {\n      var _this8 = this;\n\n      this._loopStart = this.toTicks(loopStart);\n\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopStart = _this8.loopStart;\n\n          _this8._testLoopBoundries(event);\n        });\n      }\n    }\n    /**\n     * The playback rate of the part\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n\n      this._setAll(\"playbackRate\", rate);\n    }\n    /**\n     * The number of scheduled notes in the part.\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._events.size;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Part.prototype), \"dispose\", this).call(this);\n\n      this.clear();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneEvent.getDefaults(), {\n        events: []\n      });\n    }\n  }]);\n\n  return Part;\n}(ToneEvent);","map":null,"metadata":{},"sourceType":"module"}