{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { StereoFeedbackEffect } from \"../effect/StereoFeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Chorus is a stereo chorus effect composed of a left and right delay with an [[LFO]] applied to the delayTime of each channel.\n * When [[feedback]] is set to a value larger than 0, you also get Flanger-type effects.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination().start();\n * const synth = new Tone.PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n *\n * @category Effect\n */\n\nexport var Chorus = /*#__PURE__*/function (_StereoFeedbackEffect) {\n  _inherits(Chorus, _StereoFeedbackEffect);\n\n  var _super = _createSuper(Chorus);\n\n  function Chorus() {\n    var _this;\n\n    _classCallCheck(this, Chorus);\n\n    _this = _super.call(this, optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]));\n    _this.name = \"Chorus\";\n    var options = optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]);\n    _this._depth = options.depth;\n    _this._delayTime = options.delayTime / 1000;\n    _this._lfoL = new LFO({\n      context: _this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1\n    });\n    _this._lfoR = new LFO({\n      context: _this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1,\n      phase: 180\n    });\n    _this._delayNodeL = new Delay({\n      context: _this.context\n    });\n    _this._delayNodeR = new Delay({\n      context: _this.context\n    });\n    _this.frequency = _this._lfoL.frequency;\n    readOnly(_assertThisInitialized(_this), [\"frequency\"]); // have one LFO frequency control the other\n\n    _this._lfoL.frequency.connect(_this._lfoR.frequency); // connections\n\n\n    _this.connectEffectLeft(_this._delayNodeL);\n\n    _this.connectEffectRight(_this._delayNodeR); // lfo setup\n\n\n    _this._lfoL.connect(_this._delayNodeL.delayTime);\n\n    _this._lfoR.connect(_this._delayNodeR.delayTime); // set the initial values\n\n\n    _this.depth = _this._depth;\n    _this.type = options.type;\n    _this.spread = options.spread;\n    return _this;\n  }\n\n  _createClass(Chorus, [{\n    key: \"depth\",\n    get:\n    /**\n     * The depth of the effect. A depth of 1 makes the delayTime\n     * modulate between 0 and 2*delayTime (centered around the delayTime).\n     */\n    function get() {\n      return this._depth;\n    },\n    set: function set(depth) {\n      this._depth = depth;\n      var deviation = this._delayTime * depth;\n      this._lfoL.min = Math.max(this._delayTime - deviation, 0);\n      this._lfoL.max = this._delayTime + deviation;\n      this._lfoR.min = Math.max(this._delayTime - deviation, 0);\n      this._lfoR.max = this._delayTime + deviation;\n    }\n    /**\n     * The delayTime in milliseconds of the chorus. A larger delayTime\n     * will give a more pronounced effect. Nominal range a delayTime\n     * is between 2 and 20ms.\n     */\n\n  }, {\n    key: \"delayTime\",\n    get: function get() {\n      return this._delayTime * 1000;\n    },\n    set: function set(delayTime) {\n      this._delayTime = delayTime / 1000;\n      this.depth = this._depth;\n    }\n    /**\n     * The oscillator type of the LFO.\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._lfoL.type;\n    },\n    set: function set(type) {\n      this._lfoL.type = type;\n      this._lfoR.type = type;\n    }\n    /**\n     * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n     * When set to 180, LFO's will be panned hard left and right respectively.\n     */\n\n  }, {\n    key: \"spread\",\n    get: function get() {\n      return this._lfoR.phase - this._lfoL.phase;\n    },\n    set: function set(spread) {\n      this._lfoL.phase = 90 - spread / 2;\n      this._lfoR.phase = spread / 2 + 90;\n    }\n    /**\n     * Start the effect.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time) {\n      this._lfoL.start(time);\n\n      this._lfoR.start(time);\n\n      return this;\n    }\n    /**\n     * Stop the lfo\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._lfoL.stop(time);\n\n      this._lfoR.stop(time);\n\n      return this;\n    }\n    /**\n     * Sync the filter to the transport. See [[LFO.sync]]\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this._lfoL.sync();\n\n      this._lfoR.sync();\n\n      return this;\n    }\n    /**\n     * Unsync the filter from the transport.\n     */\n\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      this._lfoL.unsync();\n\n      this._lfoR.unsync();\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Chorus.prototype), \"dispose\", this).call(this);\n\n      this._lfoL.dispose();\n\n      this._lfoR.dispose();\n\n      this._delayNodeL.dispose();\n\n      this._delayNodeR.dispose();\n\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(StereoFeedbackEffect.getDefaults(), {\n        frequency: 1.5,\n        delayTime: 3.5,\n        depth: 0.7,\n        type: \"sine\",\n        spread: 180,\n        feedback: 0,\n        wet: 0.5\n      });\n    }\n  }]);\n\n  return Chorus;\n}(StereoFeedbackEffect);","map":null,"metadata":{},"sourceType":"module"}