{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport var createNativeAudioWorkletNodeFactory = function createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) {\n  return function (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) {\n    if (nativeAudioWorkletNodeConstructor !== null) {\n      try {\n        var nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n        var patchedEventListeners = new Map();\n        var onprocessorerror = null;\n        Object.defineProperties(nativeAudioWorkletNode, {\n          /*\n           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n           * browsers have no native implementation to achieve a consistent behavior.\n           */\n          channelCount: {\n            get: function get() {\n              return options.channelCount;\n            },\n            set: function set() {\n              throw createInvalidStateError();\n            }\n          },\n          channelCountMode: {\n            get: function get() {\n              return 'explicit';\n            },\n            set: function set() {\n              throw createInvalidStateError();\n            }\n          },\n          // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n          onprocessorerror: {\n            get: function get() {\n              return onprocessorerror;\n            },\n            set: function set(value) {\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n              }\n\n              onprocessorerror = typeof value === 'function' ? value : null;\n\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n              }\n            }\n          }\n        });\n\n        nativeAudioWorkletNode.addEventListener = function (addEventListener) {\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            if (args[0] === 'processorerror') {\n              var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : _typeof(args[1]) === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n              if (unpatchedEventListener !== null) {\n                var patchedEventListener = patchedEventListeners.get(args[1]);\n\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = function (event) {\n                    // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n                    if (event.type === 'error') {\n                      Object.defineProperties(event, {\n                        type: {\n                          value: 'processorerror'\n                        }\n                      });\n                      unpatchedEventListener(event);\n                    } else {\n                      unpatchedEventListener(new ErrorEvent(args[0], _objectSpread({}, event)));\n                    }\n                  };\n\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            } // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n\n\n            addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n            return addEventListener.call.apply(addEventListener, [nativeAudioWorkletNode].concat(args));\n          };\n        }(nativeAudioWorkletNode.addEventListener);\n\n        nativeAudioWorkletNode.removeEventListener = function (removeEventListener) {\n          return function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            if (args[0] === 'processorerror') {\n              var patchedEventListener = patchedEventListeners.get(args[1]);\n\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners.delete(args[1]);\n                args[1] = patchedEventListener;\n              }\n            } // Bug #178: Chrome, Edge and Opera do fire an event of type error.\n\n\n            removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        }(nativeAudioWorkletNode.removeEventListener);\n        /*\n         * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n         * has an output.\n         */\n\n\n        if (options.numberOfOutputs !== 0) {\n          var nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n          var whenConnected = function whenConnected() {\n            return nativeGainNode.disconnect();\n          };\n\n          var whenDisconnected = function whenDisconnected() {\n            return nativeGainNode.connect(nativeContext.destination);\n          }; // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n\n\n          return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n        }\n\n        return nativeAudioWorkletNode;\n      } catch (err) {\n        // Bug #60: Chrome, Edge & Opera throw an InvalidStateError instead of a NotSupportedError.\n        if (err.code === 11) {\n          throw createNotSupportedError();\n        }\n\n        throw err;\n      }\n    } // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n\n    if (processorConstructor === undefined) {\n      throw createNotSupportedError();\n    }\n\n    testClonabilityOfAudioWorkletNodeOptions(options);\n    return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n  };\n};","map":null,"metadata":{},"sourceType":"module"}