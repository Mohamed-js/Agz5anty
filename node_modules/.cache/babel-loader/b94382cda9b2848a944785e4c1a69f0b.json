{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport var ToneAudioBuffer = /*#__PURE__*/function (_Tone) {\n  _inherits(ToneAudioBuffer, _Tone);\n\n  var _super = _createSuper(ToneAudioBuffer);\n\n  function ToneAudioBuffer() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioBuffer);\n\n    _this = _super.call(this);\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url).catch(options.onerror);\n    }\n\n    return _this;\n  }\n\n  _createClass(ToneAudioBuffer, [{\n    key: \"sampleRate\",\n    get:\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    function get() {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(buffer) {\n      var _this2 = this;\n\n      if (buffer instanceof ToneAudioBuffer) {\n        // if it's loaded, set it\n        if (buffer.loaded) {\n          this._buffer = buffer.get();\n        } else {\n          // otherwise when it's loaded, invoke it's callback\n          buffer.onload = function () {\n            _this2.set(buffer);\n\n            _this2.onload(_this2);\n          };\n        }\n      } else {\n        this._buffer = buffer;\n      } // reverse it initially\n\n\n      if (this._reversed) {\n        this._reverse();\n      }\n\n      return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var doneLoading, index;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                doneLoading = ToneAudioBuffer.load(url).then(function (audioBuffer) {\n                  _this3.set(audioBuffer); // invoke the onload method\n\n\n                  _this3.onload(_this3);\n                });\n                ToneAudioBuffer.downloads.push(doneLoading);\n                _context.prev = 2;\n                _context.next = 5;\n                return doneLoading;\n\n              case 5:\n                _context.prev = 5;\n                // remove the downloaded file\n                index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n                return _context.finish(5);\n\n              case 9:\n                return _context.abrupt(\"return\", this);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2,, 5, 9]]);\n      }));\n    }\n    /**\n     * clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioBuffer.prototype), \"dispose\", this).call(this);\n\n      this._buffer = undefined;\n      return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var isMultidimensional = isArray(array) && array[0].length > 0;\n      var channels = isMultidimensional ? array.length : 1;\n      var len = isMultidimensional ? array[0].length : array.length;\n      var context = getContext();\n      var buffer = context.createBuffer(channels, len, context.sampleRate);\n      var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n      for (var c = 0; c < channels; c++) {\n        buffer.copyToChannel(multiChannelArray[c], c);\n      }\n\n      this._buffer = buffer;\n      return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toMono\",\n    value: function toMono(chanNum) {\n      if (isNumber(chanNum)) {\n        this.fromArray(this.toArray(chanNum));\n      } else {\n        var outputArray = new Float32Array(this.length);\n        var numChannels = this.numberOfChannels;\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          var channelArray = this.toArray(channel);\n\n          for (var i = 0; i < channelArray.length; i++) {\n            outputArray[i] += channelArray[i];\n          }\n        } // divide by the number of channels\n\n\n        outputArray = outputArray.map(function (sample) {\n          return sample / numChannels;\n        });\n        this.fromArray(outputArray);\n      }\n\n      return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(channel) {\n      if (isNumber(channel)) {\n        return this.getChannelData(channel);\n      } else if (this.numberOfChannels === 1) {\n        return this.toArray(0);\n      } else {\n        var ret = [];\n\n        for (var c = 0; c < this.numberOfChannels; c++) {\n          ret[c] = this.getChannelData(c);\n        }\n\n        return ret;\n      }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n\n  }, {\n    key: \"getChannelData\",\n    value: function getChannelData(channel) {\n      if (this._buffer) {\n        return this._buffer.getChannelData(channel);\n      } else {\n        return new Float32Array(0);\n      }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var startSamples = Math.floor(start * this.sampleRate);\n      var endSamples = Math.floor(end * this.sampleRate);\n      assert(startSamples < endSamples, \"The start time must be less than the end time\");\n      var length = endSamples - startSamples;\n      var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n      for (var channel = 0; channel < this.numberOfChannels; channel++) {\n        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n      }\n\n      return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"_reverse\",\n    value: function _reverse() {\n      if (this.loaded) {\n        for (var i = 0; i < this.numberOfChannels; i++) {\n          this.getChannelData(i).reverse();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n\n  }, {\n    key: \"numberOfChannels\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"reverse\",\n    get: function get() {\n      return this._reversed;\n    },\n    set: function set(rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n\n        this._reverse();\n      }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        onerror: noOp,\n        onload: noOp,\n        reverse: false\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n\n  }, {\n    key: \"fromUrl\",\n    value: function fromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                buffer = new ToneAudioBuffer();\n                _context2.next = 3;\n                return buffer.load(url);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var matches, extensions, extension, _iterator, _step, ext, baseUrl, response, arrayBuffer, audioBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // test if the url contains multiple extensions\n                matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\n                if (!matches) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                extensions = matches[1].split(\"|\");\n                extension = extensions[0];\n                _iterator = _createForOfIteratorHelper(extensions);\n                _context3.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                ext = _step.value;\n\n                if (!ToneAudioBuffer.supportsType(ext)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                extension = ext;\n                return _context3.abrupt(\"break\", 14);\n\n              case 12:\n                _context3.next = 7;\n                break;\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                _iterator.e(_context3.t0);\n\n              case 19:\n                _context3.prev = 19;\n\n                _iterator.f();\n\n                return _context3.finish(19);\n\n              case 22:\n                url = url.replace(matches[0], extension);\n\n              case 23:\n                // make sure there is a slash between the baseUrl and the url\n                baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n                _context3.next = 26;\n                return fetch(baseUrl + url);\n\n              case 26:\n                response = _context3.sent;\n\n                if (response.ok) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                throw new Error(\"could not load url: \".concat(url));\n\n              case 29:\n                _context3.next = 31;\n                return response.arrayBuffer();\n\n              case 31:\n                arrayBuffer = _context3.sent;\n                _context3.next = 34;\n                return getContext().decodeAudioData(arrayBuffer);\n\n              case 34:\n                audioBuffer = _context3.sent;\n                return _context3.abrupt(\"return\", audioBuffer);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[5, 16, 19, 22]]);\n      }));\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n\n  }, {\n    key: \"supportsType\",\n    value: function supportsType(url) {\n      var extensions = url.split(\".\");\n      var extension = extensions[extensions.length - 1];\n      var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n      return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.resolve();\n\n              case 2:\n                if (!ToneAudioBuffer.downloads.length) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 5;\n                return ToneAudioBuffer.downloads[0];\n\n              case 5:\n                _context4.next = 2;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return ToneAudioBuffer;\n}(Tone); //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","map":null,"metadata":{},"sourceType":"module"}