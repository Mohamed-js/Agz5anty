{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nexport var PolySynth = /*#__PURE__*/function (_Instrument) {\n  _inherits(PolySynth, _Instrument);\n\n  var _super = _createSuper(PolySynth);\n\n  function PolySynth() {\n    var _this;\n\n    _classCallCheck(this, PolySynth);\n\n    _this = _super.call(this, optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    _this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    _this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    _this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    _this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    _this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    _this._averageActiveVoices = 0;\n    var options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    var defaults = options.voice.getDefaults();\n    _this.options = Object.assign(defaults, options.options);\n    _this.voice = options.voice;\n    _this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    _this._dummyVoice = _this._getNextAvailableVoice(); // remove it from the voices list\n\n    var index = _this._voices.indexOf(_this._dummyVoice);\n\n    _this._voices.splice(index, 1); // kick off the GC interval\n\n\n    _this._gcTimeout = _this.context.setInterval(_this._collectGarbage.bind(_assertThisInitialized(_this)), 1);\n    return _this;\n  }\n\n  _createClass(PolySynth, [{\n    key: \"activeVoices\",\n    get:\n    /**\n     * The number of active voices.\n     */\n    function get() {\n      return this._activeVoices.length;\n    }\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n\n  }, {\n    key: \"_makeVoiceAvailable\",\n    value: function _makeVoiceAvailable(voice) {\n      this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n      var activeVoiceIndex = this._activeVoices.findIndex(function (e) {\n        return e.voice === voice;\n      });\n\n      this._activeVoices.splice(activeVoiceIndex, 1);\n    }\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n\n  }, {\n    key: \"_getNextAvailableVoice\",\n    value: function _getNextAvailableVoice() {\n      // if there are available voices, return the first one\n      if (this._availableVoices.length) {\n        return this._availableVoices.shift();\n      } else if (this._voices.length < this.maxPolyphony) {\n        // otherwise if there is still more maxPolyphony, make a new voice\n        var voice = new this.voice(Object.assign(this.options, {\n          context: this.context,\n          onsilence: this._makeVoiceAvailable.bind(this)\n        }));\n        voice.connect(this.output);\n\n        this._voices.push(voice);\n\n        return voice;\n      } else {\n        warn(\"Max polyphony exceeded. Note dropped.\");\n      }\n    }\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n\n  }, {\n    key: \"_collectGarbage\",\n    value: function _collectGarbage() {\n      this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n      if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n        // take off an available note\n        var firstAvail = this._availableVoices.shift();\n\n        var index = this._voices.indexOf(firstAvail);\n\n        this._voices.splice(index, 1);\n\n        if (!this.context.isOffline) {\n          firstAvail.dispose();\n        }\n      }\n    }\n    /**\n     * Internal method which triggers the attack\n     */\n\n  }, {\n    key: \"_triggerAttack\",\n    value: function _triggerAttack(notes, time, velocity) {\n      var _this2 = this;\n\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this2.context, note).toMidi();\n\n        var voice = _this2._getNextAvailableVoice();\n\n        if (voice) {\n          voice.triggerAttack(note, time, velocity);\n\n          _this2._activeVoices.push({\n            midi: midiNote,\n            voice: voice,\n            released: false\n          });\n\n          _this2.log(\"triggerAttack\", note, time);\n        }\n      });\n    }\n    /**\n     * Internal method which triggers the release\n     */\n\n  }, {\n    key: \"_triggerRelease\",\n    value: function _triggerRelease(notes, time) {\n      var _this3 = this;\n\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this3.context, note).toMidi();\n\n        var event = _this3._activeVoices.find(function (_ref) {\n          var midi = _ref.midi,\n              released = _ref.released;\n          return midi === midiNote && !released;\n        });\n\n        if (event) {\n          // trigger release on that note\n          event.voice.triggerRelease(time); // mark it as released\n\n          event.released = true;\n\n          _this3.log(\"triggerRelease\", note, time);\n        }\n      });\n    }\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n\n  }, {\n    key: \"_scheduleEvent\",\n    value: function _scheduleEvent(type, notes, time, velocity) {\n      var _this4 = this;\n\n      assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n      if (time <= this.now()) {\n        // do it immediately\n        if (type === \"attack\") {\n          this._triggerAttack(notes, time, velocity);\n        } else {\n          this._triggerRelease(notes, time);\n        }\n      } else {\n        // schedule it to start in the future\n        this.context.setTimeout(function () {\n          _this4._scheduleEvent(type, notes, time, velocity);\n        }, time - this.now());\n      }\n    }\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n     */\n\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(notes, time, velocity) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      var computedTime = this.toSeconds(time);\n\n      this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n      return this;\n    }\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(notes, time) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      var computedTime = this.toSeconds(time);\n\n      this._scheduleEvent(\"release\", notes, computedTime);\n\n      return this;\n    }\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(notes, duration, time, velocity) {\n      var computedTime = this.toSeconds(time);\n      this.triggerAttack(notes, computedTime, velocity);\n\n      if (isArray(duration)) {\n        assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n        notes = notes;\n\n        for (var i = 0; i < notes.length; i++) {\n          var d = duration[Math.min(i, duration.length - 1)];\n          var durationSeconds = this.toSeconds(d);\n          assert(durationSeconds > 0, \"The duration must be greater than 0\");\n          this.triggerRelease(notes[i], computedTime + durationSeconds);\n        }\n      } else {\n        var _durationSeconds = this.toSeconds(duration);\n\n        assert(_durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes, computedTime + _durationSeconds);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 1);\n\n        this._syncMethod(\"triggerRelease\", 1);\n      }\n\n      return this;\n    }\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * const poly = new Tone.PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(options) {\n      // remove options which are controlled by the PolySynth\n      var sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n      this.options = deepMerge(this.options, sanitizedOptions);\n\n      this._voices.forEach(function (voice) {\n        return voice.set(sanitizedOptions);\n      });\n\n      this._dummyVoice.set(sanitizedOptions);\n\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._dummyVoice.get();\n    }\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n\n  }, {\n    key: \"releaseAll\",\n    value: function releaseAll(time) {\n      var computedTime = this.toSeconds(time);\n\n      this._activeVoices.forEach(function (_ref2) {\n        var voice = _ref2.voice;\n        voice.triggerRelease(computedTime);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(PolySynth.prototype), \"dispose\", this).call(this);\n\n      this._dummyVoice.dispose();\n\n      this._voices.forEach(function (v) {\n        return v.dispose();\n      });\n\n      this._activeVoices = [];\n      this._availableVoices = [];\n      this.context.clearInterval(this._gcTimeout);\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        maxPolyphony: 32,\n        options: {},\n        voice: Synth\n      });\n    }\n  }]);\n\n  return PolySynth;\n}(Instrument);","map":null,"metadata":{},"sourceType":"module"}