{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport var ToneAudioNode = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(ToneAudioNode, _ToneWithContext);\n\n  var _super = _createSuper(ToneAudioNode);\n\n  function ToneAudioNode() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioNode);\n\n    _this = _super.apply(this, arguments);\n    /**\n     * The name of the class\n     */\n\n    _this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    _this._internalChannels = [];\n    return _this;\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  _createClass(ToneAudioNode, [{\n    key: \"numberOfInputs\",\n    get: function get() {\n      if (isDefined(this.input)) {\n        if (isAudioParam(this.input) || this.input instanceof Param) {\n          return 1;\n        } else {\n          return this.input.numberOfInputs;\n        }\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n\n  }, {\n    key: \"numberOfOutputs\",\n    get: function get() {\n      if (isDefined(this.output)) {\n        return this.output.numberOfOutputs;\n      } else {\n        return 0;\n      }\n    } //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n\n  }, {\n    key: \"_isAudioNode\",\n    value: function _isAudioNode(node) {\n      return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n\n  }, {\n    key: \"_getInternalNodes\",\n    value: function _getInternalNodes() {\n      var nodeList = this._internalChannels.slice(0);\n\n      if (this._isAudioNode(this.input)) {\n        nodeList.push(this.input);\n      }\n\n      if (this._isAudioNode(this.output)) {\n        if (this.input !== this.output) {\n          nodeList.push(this.output);\n        }\n      }\n\n      return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n\n  }, {\n    key: \"_setChannelProperties\",\n    value: function _setChannelProperties(options) {\n      var nodeList = this._getInternalNodes();\n\n      nodeList.forEach(function (node) {\n        node.channelCount = options.channelCount;\n        node.channelCountMode = options.channelCountMode;\n        node.channelInterpretation = options.channelInterpretation;\n      });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n\n  }, {\n    key: \"_getChannelProperties\",\n    value: function _getChannelProperties() {\n      var nodeList = this._getInternalNodes();\n\n      assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n      // they should all be the same\n\n      var node = nodeList[0];\n      return {\n        channelCount: node.channelCount,\n        channelCountMode: node.channelCountMode,\n        channelInterpretation: node.channelInterpretation\n      };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n\n  }, {\n    key: \"channelCount\",\n    get: function get() {\n      return this._getChannelProperties().channelCount;\n    },\n    set: function set(channelCount) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCount: channelCount\n      }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n\n  }, {\n    key: \"channelCountMode\",\n    get: function get() {\n      return this._getChannelProperties().channelCountMode;\n    },\n    set: function set(channelCountMode) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCountMode: channelCountMode\n      }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n\n  }, {\n    key: \"channelInterpretation\",\n    get: function get() {\n      return this._getChannelProperties().channelInterpretation;\n    },\n    set: function set(channelInterpretation) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelInterpretation: channelInterpretation\n      }));\n    } //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _connect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n\n  }, {\n    key: \"toDestination\",\n    value: function toDestination() {\n      this.connect(this.context.destination);\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n\n  }, {\n    key: \"toMaster\",\n    value: function toMaster() {\n      warn(\"toMaster() has been renamed toDestination()\");\n      return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _disconnect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n\n  }, {\n    key: \"chain\",\n    value: function chain() {\n      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n\n      connectSeries.apply(void 0, [this].concat(nodes));\n      return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n\n  }, {\n    key: \"fan\",\n    value: function fan() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nodes[_key2] = arguments[_key2];\n      }\n\n      nodes.forEach(function (node) {\n        return _this2.connect(node);\n      });\n      return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioNode.prototype), \"dispose\", this).call(this);\n\n      if (isDefined(this.input)) {\n        if (this.input instanceof ToneAudioNode) {\n          this.input.dispose();\n        } else if (isAudioNode(this.input)) {\n          this.input.disconnect();\n        }\n      }\n\n      if (isDefined(this.output)) {\n        if (this.output instanceof ToneAudioNode) {\n          this.output.dispose();\n        } else if (isAudioNode(this.output)) {\n          this.output.disconnect();\n        }\n      }\n\n      this._internalChannels = [];\n      return this;\n    }\n  }]);\n\n  return ToneAudioNode;\n}(ToneWithContext); //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries() {\n  for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    nodes[_key3] = arguments[_key3];\n  }\n\n  var first = nodes.shift();\n  nodes.reduce(function (prev, current) {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      _connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nfunction _connect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\n\nexport { _connect as connect };\n\nfunction _disconnect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}\n\nexport { _disconnect as disconnect };","map":null,"metadata":{},"sourceType":"module"}